// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !! THIS FILE IS AUTOMATICALLY GENERATED. EDITS WILL BE CLOBBERED !!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#pragma once

const char *shader_source_common_uniforms = R"GLSL(layout(std140) uniform CommonUniforms {
  mat4 iModelViewProjection;
  mat4 iModelView;
  mat4 iProjection;
  mat4 iInverseModelViewProjection;
  mat4 iInverseModelView;
  mat4 iInverseProjection;

  mat4 iControllerTransform[2]; // [Left, Right]
  vec4 iControllerVelocity[2];
  vec4 iControllerButtons[2];

  ivec2 iSize;

  float iTime;
  float iTimeDelta;
  int iFrame;
};

uniform sampler2D iFragData[6];
uniform ivec2 iResolution;
)GLSL";

const char *shader_source_shade_fs = R"GLSL(#version 300 es

precision highp float;
precision highp int;

// {{fragment}}

out vec4 oFragColor;

void main() {
  mainFragment(oFragColor);
}
)GLSL";

const char *shader_source_shade_vs = R"GLSL(#version 300 es

precision highp float;
precision highp int;

// {{vertex}}

// layout(location = 0) in ivec2 aParticleCoord;

void main() {
  mainVertex(gl_Position);//, aParticleCoord);
}
)GLSL";

const char *shader_source_simulation_fs = R"GLSL(#version 300 es

precision highp float;
precision highp int;

// {{simulation}}

layout(location = 0) out vec4 oFragData0;
layout(location = 1) out vec4 oFragData1;
layout(location = 2) out vec4 oFragData2;
layout(location = 3) out vec4 oFragData3;
layout(location = 4) out vec4 oFragData4;
layout(location = 5) out vec4 oFragData5;

void main() {
  mainSimulation(oFragData0, oFragData1, oFragData2, oFragData3, oFragData4, oFragData5);
}
)GLSL";

const char *shader_source_simulation_vs = R"GLSL(#version 300 es

precision highp float;
precision highp int;

layout(location = 0) in vec4 aPosition;

void main() {
  gl_Position = aPosition;
}
)GLSL";

const char *shader_source_user_default_common = R"GLSL(// The contents of this tab will be prefixed in all shaders.

const vec3 cubeVertices[8] = vec3[8](
  vec3(-1.0, -1.0, -1.0),
  vec3( 1.0, -1.0, -1.0),
  vec3(-1.0,  1.0, -1.0),
  vec3( 1.0,  1.0, -1.0),
  vec3(-1.0, -1.0,  1.0),
  vec3( 1.0, -1.0,  1.0),
  vec3(-1.0,  1.0,  1.0),
  vec3( 1.0,  1.0,  1.0)
);

const vec3 cubeNormals[6] = vec3[6](
  vec3( 0.0,  0.0, -1.0),
  vec3( 0.0, -1.0,  0.0),
  vec3(-1.0,  0.0,  0.0),
  vec3( 0.0,  1.0,  0.0),
  vec3( 1.0,  0.0,  0.0),
  vec3( 0.0,  0.0,  1.0)
);

const int cubeIndices[36] = int[36](
  0, 2, 3,
  0, 3, 1,
  0, 1, 5,
  0, 5, 4,
  0, 4, 6,
  0, 6, 2,
  7, 2, 6,
  7, 3, 2,
  7, 1, 3,
  7, 5, 1,
  7, 4, 5,
  7, 6, 4
);
)GLSL";

const char *shader_source_user_default_fragment = R"GLSL(in vec4 vColor;

void mainFragment(out vec4 oColor) {
  oColor = vColor;
}
)GLSL";

const char *shader_source_user_default_simulation = R"GLSL(/*
Welcome to Particle ShaderToy (Î±)

Camera    : Left-mouse drag in the viewport and use WASD keys to move. Use QE keys to roll.
Save/Load : Click Download to save your shader. Drag a saved .json into this window to load it.

Contribute : https://github.com/notlion/pst-alpha
*/

#pragma size 64 64

void mainSimulation(out vec4 oPosition, out vec4 oColor, out vec4 oData2, out vec4 oData3, out vec4 oData4, out vec4 oData5) {
  ivec2 coord = ivec2(gl_FragCoord);
  int id = iSize.x * coord.y + coord.x;

  float scale = 1.0 / float(max(iSize.x, iSize.y));
  vec2 pos = (gl_FragCoord.xy - vec2(iSize) * 0.5) * scale;
  oPosition = vec4(pos, -1.25, 1.0);
  
  oPosition.z += cos(distance(oPosition.xyz, vec3(0.0)) * 80.0 - iTime * 2.0) * 0.02;

  vec2 texcoord = gl_FragCoord.xy / vec2(iSize);
  oColor = vec4(texcoord, 0.0, 1.0);
}
)GLSL";

const char *shader_source_user_default_vertex = R"GLSL(#pragma vertexCount 36
#pragma cull back

out vec4 vColor;

void mainVertex(out vec4 oPosition) {
  int instanceID = gl_VertexID / 36;
  ivec2 coord = ivec2(instanceID % iSize.x, instanceID / iSize.x);

  oPosition = texelFetch(iFragData[0], coord, 0);
  oPosition.xyz += cubeVertices[cubeIndices[gl_VertexID % 36]] * 0.004;

  oPosition = iModelViewProjection * oPosition;

  vColor = texelFetch(iFragData[1], coord, 0);

  vec3 normal = cubeNormals[gl_VertexID / 6 % 6];
  vec3 lightDir = normalize(vec3(0.6, 0.3, 1.0));
  vColor *= 0.6 + 0.4 * max(0.0, dot(lightDir, normal));
}
)GLSL";
