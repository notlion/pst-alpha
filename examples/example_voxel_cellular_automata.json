{"shaders":[{"source":"const ivec3 dirs[26] = ivec3[26](\n  // Von-Neumann Faces\n  ivec3(-1,  0,  0),\n  ivec3( 0, -1,  0),\n  ivec3( 0,  0, -1),\n  ivec3( 1,  0,  0),\n  ivec3( 0,  1,  0),\n  ivec3( 0,  0,  1),\n  \n  // Moore Edges\n  ivec3(-1,  0, -1),\n  ivec3( 1,  0, -1),\n  ivec3( 0, -1, -1),\n  ivec3( 0,  1, -1),\n  \n  ivec3(-1, -1, 0),\n  ivec3( 1, -1, 0),\n  ivec3(-1,  1, 0),\n  ivec3( 1,  1, 0),\n\n  ivec3(-1,  0, 1),\n  ivec3( 1,  0, 1),\n  ivec3( 0, -1, 1),\n  ivec3( 0,  1, 1),\n\n  // Moore Corners\n  ivec3(-1, -1, -1),\n  ivec3( 1, -1, -1),\n  ivec3(-1,  1, -1),\n  ivec3( 1,  1, -1),\n  ivec3(-1, -1,  1),\n  ivec3( 1, -1,  1),\n  ivec3(-1,  1,  1),\n  ivec3( 1,  1,  1)\n);\n\nfloat hash1(uint n) {\n  n = (n << 13U) ^ n;\n  n = n * (n * n * 15731U + 789221U) + 1376312589U;\n  return float(n & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nconst int DIM = 64;\nconst int DIMDIM = DIM * DIM;\nconst int HDIM = DIM / 2;\n\nvec4 getVoxel(in ivec3 c) {\n  c = (c + DIM) % DIM; // Wrap\n  int i = c.x + c.y * DIM + c.z * DIMDIM;\n  return texelFetch(iFragData[1], ivec2(i % iSize.x, i / iSize.x), 0);\n}\n"},{"source":"#pragma size 512 512\n\nconst int C = 5;\n\nvoid mainSimulation(out vec4 oPosition, out vec4 oState, out vec4 oColor, out vec4 oData3, out vec4 oData4, out vec4 oData5) {\n  ivec2 fragCoord = ivec2(gl_FragCoord);\n  int id = fragCoord.x + fragCoord.y * iSize.x;\n\n  ivec3 coord = ivec3(id % DIM, (id % DIMDIM) / DIM, id / DIMDIM);\n  \n  oPosition = vec4(vec3(coord) / float(DIM), 1.0);\n  oColor = oPosition;\n\n  oPosition.xyz -= 0.5;\n  oPosition.z -= 1.6;\n\n  int count = 0;\n  for (int i = 0; i < 26; ++i) {\n    if (int(getVoxel(coord + dirs[i]).x) == 1) count++;\n  }\n\n  oState = texelFetch(iFragData[1], fragCoord, 0);\n\n  int gen = int(oState.x);\n  if (gen == 0) {\n    if (count == 4) { // Birth (B)\n      gen = 1;\n    }\n  }\n  else if (gen == 1 && count == 4) { // Sustain (S)\n  }\n  else {\n    gen = (gen + 1) % C;\n  }\n  oState.x = float(gen);\n\n  if (iFrame == 0) {\n    int cmin = HDIM - 5;\n    int cmax = HDIM + 5;\n    if (coord.x >= cmin && coord.y >= cmin && coord.z >= cmin && coord.x <= cmax && coord.y <= cmax && coord.z <= cmax) {\n      oState = vec4(round(hash1(uint(id)) + 0.2), 0.0, 0.0, 0.0);\n    }\n    else {\n      oState = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n  }\n\n  oColor.a *= min(1.0, oState.x);\n  oColor.g = oState.x / float(C - 1);\n  // oColor.rgb *= smoothstep(10.0, 0.0, float(count));\n}\n"},{"source":"#pragma vertexCount 36\n#pragma cull back\n\nconst vec3 cubeVertices[8] = vec3[8](\n  vec3(-1.0, -1.0, -1.0),\n  vec3( 1.0, -1.0, -1.0),\n  vec3(-1.0,  1.0, -1.0),\n  vec3( 1.0,  1.0, -1.0),\n  vec3(-1.0, -1.0,  1.0),\n  vec3( 1.0, -1.0,  1.0),\n  vec3(-1.0,  1.0,  1.0),\n  vec3( 1.0,  1.0,  1.0)\n);\n\nconst vec3 cubeNormals[6] = vec3[6](\n  vec3( 0.0,  0.0, -1.0),\n  vec3( 0.0, -1.0,  0.0),\n  vec3(-1.0,  0.0,  0.0),\n  vec3( 0.0,  1.0,  0.0),\n  vec3( 1.0,  0.0,  0.0),\n  vec3( 0.0,  0.0,  1.0)\n);\n\nconst int cubeIndices[36] = int[36](\n  0, 2, 3,\n  0, 3, 1,\n  0, 1, 5,\n  0, 5, 4,\n  0, 4, 6,\n  0, 6, 2,\n  7, 2, 6,\n  7, 3, 2,\n  7, 1, 3,\n  7, 5, 1,\n  7, 4, 5,\n  7, 6, 4\n);\n\nout vec4 vColor;\n\nvoid mainVertex(out vec4 oPosition) {\n  int instanceID = gl_VertexID / 36;\n  ivec2 fragCoord = ivec2(instanceID % iSize.x, instanceID / iSize.x);\n\n  vColor = texelFetch(iFragData[2], fragCoord, 0);\n\n  if (vColor.a == 0.0) {\n    oPosition = vec4(0.0);\n  }\n  else {\n    oPosition = texelFetch(iFragData[0], fragCoord, 0);\n    oPosition.xyz += cubeVertices[cubeIndices[gl_VertexID % 36]] * (0.5 / float(DIM));\n\n    oPosition = iModelViewProjection * oPosition;\n\n    vec3 normal = cubeNormals[gl_VertexID / 6 % 6];\n    vec3 lightDir = normalize(vec3(0.6, 0.3, 1.0));\n    vColor *= 0.6 + 0.4 * max(0.0, dot(lightDir, normal));\n  }\n}\n"},{"source":"in vec4 vColor;\n\nvoid mainFragment(out vec4 oColor) {\n  oColor = vColor;\n}\n"}]}